<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON CYBER RIDE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #bc13fe;
            --neon-green: #0aff0a;
            --bg-color: #050510;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            overflow-x: hidden;
            overscroll-behavior: none;
        }

        /* === èƒŒæ™¯ã‚­ãƒ£ãƒ³ãƒã‚¹ (Warp Drive) === */
        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        /* === ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ === */
        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            opacity: 0;
            transform: translateY(50px);
            transition: all 1s cubic-bezier(0.22, 1, 0.36, 1);
        }

        section.visible {
            opacity: 1;
            transform: translateY(0);
        }

        h1, h2 {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 243, 255, 0.5);
        }

        h1 { font-size: 3rem; margin-bottom: 0.5rem; color: var(--neon-blue); }
        h2 { font-size: 2rem; color: var(--neon-pink); }
        p { font-size: 1.2rem; max-width: 600px; text-align: center; line-height: 1.8; text-shadow: 0 0 5px rgba(0,0,0,0.8); }

        /* === Gimmick 1: Hacker Text === */
        .hacker-text {
            font-family: monospace;
            color: var(--neon-green);
            background: rgba(0, 20, 0, 0.6);
            padding: 10px 20px;
            border: 1px solid var(--neon-green);
            border-radius: 5px;
        }

        /* === Gimmick 2: 3D Tilt Card === */
        .card-container {
            perspective: 1000px;
            width: 300px;
            height: 400px;
            margin: 50px auto;
        }
        .card {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(188, 19, 254, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
            transform-style: preserve-3d;
            cursor: pointer;
        }
        .card h3 {
            font-size: 4rem;
            margin: 0;
            transform: translateZ(50px);
        }
        .card p {
            font-size: 1rem;
            transform: translateZ(30px);
        }

        /* === Gimmick 3: Energy Core === */
        .core-wrapper {
            position: relative;
            width: 200px;
            height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .core {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #fff, var(--neon-blue));
            border-radius: 50%;
            box-shadow: 0 0 20px var(--neon-blue);
            cursor: pointer;
            transition: transform 0.1s;
            animation: pulse 2s infinite;
        }
        .core:active {
            transform: scale(0.9);
        }
        .core-ring {
            position: absolute;
            border: 2px dashed var(--neon-blue);
            border-radius: 50%;
            width: 160px;
            height: 160px;
            animation: spin 10s linear infinite;
        }
        .core-ring:nth-child(2) {
            width: 180px; height: 180px;
            border-color: var(--neon-pink);
            animation: spin 5s linear infinite reverse;
        }

        /* Animations */
        @keyframes pulse { 0% { box-shadow: 0 0 20px var(--neon-blue); } 50% { box-shadow: 0 0 60px var(--neon-blue), 0 0 100px var(--neon-blue); } 100% { box-shadow: 0 0 20px var(--neon-blue); } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { transform: translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }

        .shaking { animation: shake 0.5s; }

        /* Hint UI */
        .scroll-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
            opacity: 0.7;
        }
        @keyframes bounce { 0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);} 40% {transform: translateX(-50%) translateY(-20px);} 60% {transform: translateX(-50%) translateY(-10px);} }

    </style>
</head>
<body>

    <canvas id="bgCanvas"></canvas>

    <section id="s1">
        <h1 class="hacker-text" data-value="CYBER DIVE">CYBER DIVE</h1>
        <p>ã‚ˆã†ã“ãã€ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ»ãƒ•ãƒ­ãƒ³ãƒ†ã‚£ã‚¢ã¸ã€‚<br>ç”»é¢ã‚’ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã—ã¦ã€æ·±å±¤éƒ¨ã¸ãƒ€ã‚¤ãƒ–ã—ã¦ãã ã•ã„ã€‚<br>ç”»é¢ã®ã©ã“ã‹ã‚’ã‚¿ãƒƒãƒ—ã™ã‚‹ã¨å…‰ãŒå¼¾ã‘ã¾ã™ã€‚</p>
        <div class="scroll-hint">â–¼ SCROLL or SWIPE â–¼</div>
    </section>

    <section id="s2">
        <h2>OBJECT_01: HOLO-CARD</h2>
        <p>ä¸‹ã®ã‚«ãƒ¼ãƒ‰ã‚’è§¦ã£ã¦ã¿ã¦ãã ã•ã„ã€‚<br>ãƒ‡ãƒã‚¤ã‚¹ã®å‚¾ãã‚„æŒ‡ã®å‹•ãã«è¿½å¾“ã—ã¾ã™ã€‚</p>
        <div class="card-container">
            <div class="card" id="tiltCard">
                <h3>3D</h3>
                <p>INTERACTIVE</p>
                <div style="font-size:3rem; margin-top:20px;">ğŸ’ </div>
            </div>
        </div>
    </section>

    <section id="s3">
        <h2>SYSTEM DECRYPTION</h2>
        <p>æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚<br>ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹ã“ã¨ã§è§£èª­ã•ã‚Œã¾ã™ã€‚</p>
        <div style="margin-top: 30px;">
            <p class="hacker-text" data-value="ACCESS GRANTED" style="font-size: 2rem;">***************</p>
            <p class="hacker-text" data-value="PROTOCOL: OMEGA" style="margin-top:10px;">***************</p>
        </div>
    </section>

    <section id="s4">
        <h2>ENERGY CORE</h2>
        <p>ã‚³ã‚¢ã‚’é•·æŠ¼ã—ï¼ˆã‚¿ãƒƒãƒ—é€£æ‰“ï¼‰ã—ã¦<br>ã‚¨ãƒãƒ«ã‚®ãƒ¼ã‚’å……å¡«ã—ã¦ãã ã•ã„ã€‚</p>
        <div class="core-wrapper">
            <div class="core-ring"></div>
            <div class="core-ring"></div>
            <div class="core" id="energyCore"></div>
        </div>
        <p id="coreStatus" style="margin-top:20px; color: var(--neon-blue);">ENERGY: 0%</p>
    </section>

    <section id="s5">
        <h1>COMPLETE</h1>
        <p>æœ€æ·±éƒ¨ã«åˆ°é”ã—ã¾ã—ãŸã€‚<br>ã“ã“ã‹ã‚‰å…ˆã¯ç„¡é™ã®å½¼æ–¹ã§ã™ã€‚</p>
        <button onclick="window.scrollTo({top:0, behavior:'smooth'})" style="margin-top:30px; padding:15px 30px; background:transparent; border:2px solid var(--neon-pink); color:#fff; font-family:'Orbitron'; font-size:1.2rem; border-radius:30px; cursor:pointer;">REBOOT SYSTEM</button>
    </section>

<script>
    /* ==========================================
       1. STAR WARP BACKGROUND (Canvas)
       ========================================== */
    const canvas = document.getElementById('bgCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let stars = [];
    let speed = 2;
    let baseSpeed = 2;
    let targetSpeed = 2;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        initStars();
    }

    function initStars() {
        stars = [];
        const starCount = Math.floor((width * height) / 2000); // ç”»é¢ã‚µã‚¤ã‚ºã«å¿œã˜ã¦æ˜Ÿã®æ•°ã‚’èª¿æ•´
        for (let i = 0; i < starCount; i++) {
            stars.push({
                x: Math.random() * width - width / 2,
                y: Math.random() * height - height / 2,
                z: Math.random() * width
            });
        }
    }

    function drawStars() {
        // èƒŒæ™¯ã‚’å°‘ã—æ®‹ã—ã¦è»Œè·¡ã‚’æã
        ctx.fillStyle = 'rgba(5, 5, 16, 0.4)';
        ctx.fillRect(0, 0, width, height);

        // ã‚¹ãƒ”ãƒ¼ãƒ‰ã®æ…£æ€§å‡¦ç†
        speed += (targetSpeed - speed) * 0.1;

        ctx.fillStyle = '#fff';
        stars.forEach(star => {
            star.z -= speed;
            if (star.z <= 0) {
                star.z = width;
                star.x = Math.random() * width - width / 2;
                star.y = Math.random() * height - height / 2;
            }

            const x = (star.x / star.z) * width + width / 2;
            const y = (star.y / star.z) * height + height / 2;
            const size = (1 - star.z / width) * 4;

            if (x > 0 && x < width && y > 0 && y < height) {
                const alpha = (1 - star.z / width);
                ctx.fillStyle = `rgba(${200 + Math.random()*55}, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        });

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°ã¨æç”»
        updateParticles();

        requestAnimationFrame(drawStars);
    }

    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ã«å¿œã˜ã¦æ˜Ÿã®ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚’å¤‰ãˆã‚‹
    let lastScrollY = window.scrollY;
    window.addEventListener('scroll', () => {
        const currentScrollY = window.scrollY;
        const delta = Math.abs(currentScrollY - lastScrollY);
        targetSpeed = baseSpeed + delta * 0.5; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã§åŠ é€Ÿ
        
        // æ•°ç§’å¾Œã«æ¸›é€Ÿ
        clearTimeout(window.scrollTimeout);
        window.scrollTimeout = setTimeout(() => {
            targetSpeed = baseSpeed;
        }, 100);
        
        lastScrollY = currentScrollY;
    });

    window.addEventListener('resize', resize);
    resize();
    drawStars();


    /* ==========================================
       2. INTERACTIVE PARTICLES (Touch/Click)
       ========================================== */
    let particles = [];

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 1.0;
            this.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.02;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 10; i++) {
            particles.push(new Particle(x, y));
        }
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw(ctx);
            if (particles[i].life <= 0) particles.splice(i, 1);
        }
    }

    // ã‚¿ãƒƒãƒï¼†ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
    ['mousedown', 'touchstart'].forEach(evt => {
        window.addEventListener(evt, (e) => {
            const x = e.touches ? e.touches[0].clientX : e.clientX;
            const y = e.touches ? e.touches[0].clientY : e.clientY;
            createExplosion(x, y);
            
            // ã‚³ã‚¢è¦ç´ ä»¥å¤–ãªã‚‰å°‘ã—åŠ é€Ÿã•ã›ã‚‹æ¼”å‡º
            if(e.target.id !== 'energyCore') {
                targetSpeed = 20;
                setTimeout(() => targetSpeed = baseSpeed, 300);
            }
        });
    });


    /* ==========================================
       3. SCROLL ANIMATIONS (Intersection Observer)
       ========================================== */
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
                
                // ãƒãƒƒã‚«ãƒ¼ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç™ºç«
                const hackers = entry.target.querySelectorAll('.hacker-text');
                hackers.forEach(el => startHackerEffect(el));
            }
        });
    }, { threshold: 0.3 });

    document.querySelectorAll('section').forEach(sec => observer.observe(sec));


    /* ==========================================
       4. GIMMICK: HACKER TEXT EFFECT
       ========================================== */
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*";
    
    function startHackerEffect(element) {
        let iterations = 0;
        const originalText = element.dataset.value;
        if(!originalText) return;

        clearInterval(element.interval);
        
        element.interval = setInterval(() => {
            element.innerText = originalText.split("")
                .map((letter, index) => {
                    if(index < iterations) {
                        return originalText[index];
                    }
                    return chars[Math.floor(Math.random() * chars.length)];
                })
                .join("");

            if(iterations >= originalText.length){ 
                clearInterval(element.interval);
            }
            
            iterations += 1/3; // ã‚¹ãƒ”ãƒ¼ãƒ‰èª¿æ•´
        }, 30);
    }


    /* ==========================================
       5. GIMMICK: 3D TILT CARD
       ========================================== */
    const card = document.getElementById('tiltCard');
    const container = document.querySelector('.card-container');

    container.addEventListener('mousemove', (e) => {
        const rect = container.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        rotateCard(x, y, rect.width, rect.height);
    });

    container.addEventListener('touchmove', (e) => {
        e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ï¼ˆã“ã®ã‚¨ãƒªã‚¢ã ã‘ï¼‰
        const rect = container.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        const y = e.touches[0].clientY - rect.top;
        rotateCard(x, y, rect.width, rect.height);
    }, { passive: false });

    container.addEventListener('mouseleave', resetCard);
    container.addEventListener('touchend', resetCard);

    function rotateCard(x, y, w, h) {
        const xPct = x / w;
        const yPct = y / h;
        const xRot = (0.5 - yPct) * 30; // Xè»¸å›è»¢ï¼ˆä¸Šä¸‹ï¼‰
        const yRot = (xPct - 0.5) * 30; // Yè»¸å›è»¢ï¼ˆå·¦å³ï¼‰
        
        card.style.transform = `rotateX(${xRot}deg) rotateY(${yRot}deg)`;
    }

    function resetCard() {
        card.style.transform = `rotateX(0deg) rotateY(0deg)`;
    }


    /* ==========================================
       6. GIMMICK: ENERGY CORE
       ========================================== */
    const core = document.getElementById('energyCore');
    const statusText = document.getElementById('coreStatus');
    let energy = 0;

    function chargeCore() {
        energy += 10;
        if (energy > 100) energy = 100;
        updateCoreVisuals();
        createExplosion(
            core.getBoundingClientRect().left + 50, 
            core.getBoundingClientRect().top + 50
        );
        
        // ç”»é¢æºã‚Œ
        if(energy > 50) document.body.classList.add('shaking');
        setTimeout(() => document.body.classList.remove('shaking'), 200);
    }

    function updateCoreVisuals() {
        statusText.innerText = `ENERGY: ${energy}%`;
        statusText.style.color = `hsl(${180 + energy}, 100%, 60%)`;
        core.style.background = `radial-gradient(circle, #fff, hsl(${180 + energy}, 100%, 50%))`;
        core.style.boxShadow = `0 0 ${20 + energy}px hsl(${180 + energy}, 100%, 50%)`;
        
        if (energy >= 100) {
            statusText.innerText = "MAXIMUM POWER REACHED!!";
            // ãƒãƒƒã‚¯ã‚¹æ™‚ã®æ¼”å‡ºï¼šèƒŒæ™¯åŠ é€Ÿ
            targetSpeed = 50;
            setTimeout(() => { targetSpeed = baseSpeed; energy = 0; updateCoreVisuals(); }, 2000);
        }
    }

    core.addEventListener('mousedown', chargeCore);
    core.addEventListener('touchstart', (e) => { e.preventDefault(); chargeCore(); });

</script>
</body>
</html>
